{
  "language": "Solidity",
  "sources": {
    "contracts/PresaleVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    error OwnableUnauthorizedAccount(address account);\r\n    error OwnableInvalidOwner(address owner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\ninterface AggregatorV3Interface {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function description() external view returns (string memory);\r\n\r\n    function version() external view returns (uint256);\r\n\r\n    function getRoundData(\r\n        uint80 _roundId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}\r\ncontract PresaleVault is Ownable {\r\n    error NeedGreaterThanCurrent();\r\n    error RoundAlreadyStarted();\r\n    error AlreadySet();\r\n    error Round3NotFinished();\r\n    error NotStarted();\r\n    error AmountNotAvailableForSale();\r\n    error RoundNotMatch();\r\n    error TransferFailed();\r\n    error SCNotAllowed();\r\n    error AlreadyEnabled();\r\n    error Invalid();\r\n    error ClaimNotEnabled();\r\n    error DelayNotOver();\r\n    error NoAmountToClaim();\r\n    error LengthError();\r\n    error AmountZero();\r\n    IERC20 private token;\r\n    TokenPriceInUSD private tokenPriceInUSD;\r\n    uint256 private precision = 10000000;\r\n    uint256 private minDaysBetweenClaims;\r\n    ClaimPercentages private claimPercentages;\r\n    address payable projectWallet;\r\n    uint256 private roundPeriod;\r\n    AggregatorV3Interface priceFeed;\r\n    mapping(address => bool) private isAllowedStableCoin;\r\n    mapping(address => UserInfo) private userInfo;\r\n    RoundTimeInfo private roundTimeInfo;\r\n    RoundHardCapInfo private roundHardCapInfo;\r\n    RoundTokenSaleInfo private roundTokenSaleInfo;\r\n    PresaleInfo private presaleInfo;\r\n    bool private isClaimEnabled;\r\n    uint256 private claimStartAt;\r\n\r\n    struct RoundTimeInfo {\r\n        uint256 r1StartTime;\r\n        uint256 r1EndTime;\r\n        uint256 r2StartTime;\r\n        uint256 r2EndTime;\r\n        uint256 r3StartTime;\r\n        uint256 r3EndTime;\r\n    }\r\n\r\n    struct RoundHardCapInfo {\r\n        uint256 r1HardCap;\r\n        uint256 r2HardCap;\r\n        uint256 r3HardCap;\r\n    }\r\n\r\n    struct RoundTokenSaleInfo {\r\n        uint256 r1SoldToken;\r\n        uint256 r1TokenForSale;\r\n        uint256 r2SoldToken;\r\n        uint256 r2TokenForSale;\r\n        uint256 r3SoldToken;\r\n        uint256 r3TokenForSale;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 r1Purchased;\r\n        uint256 r2Purchased;\r\n        uint256 r3Purchased;\r\n        uint256 r1Claimed;\r\n        uint256 r2Claimed;\r\n        uint256 r3Claimed;\r\n        uint256 totalSCInvested;\r\n        uint256 totalETHInvested;\r\n        uint256 lastClaimedAt;\r\n        uint256 totalPurchased;\r\n        uint256 totalClaimed;\r\n        uint256 remainToClaim;\r\n    }\r\n\r\n    struct PresaleInfo {\r\n        uint256 raisedTotalETH;\r\n        uint256 raisedTotalSCToken;\r\n        uint256 soldToken;\r\n    }\r\n\r\n    struct TokenPriceInUSD {\r\n        uint256 presale1;\r\n        uint256 presale2;\r\n        uint256 presale3;\r\n    }\r\n    struct ClaimPercentages {\r\n        uint256 presale1;\r\n        uint256 presale2;\r\n        uint256 presale3;\r\n    }\r\n    enum PaymentType {\r\n        ETH,\r\n        StableCoin\r\n    }\r\n\r\n    event TokenPurchased(\r\n        uint256 indexed tokenAmount,\r\n        uint256 indexed amountPaidInUSD,\r\n        address purchaser\r\n    );\r\n    event TokenClaimed(\r\n        uint256 indexed amountclaimed,\r\n        uint256 indexed timestamp,\r\n        address claimer\r\n    );\r\n\r\n    constructor(\r\n        address _token,\r\n        address[] memory _allowedStableCoins,\r\n        uint256 _startingTime,\r\n        address payable _pWallet,\r\n        RoundHardCapInfo memory _capInfo,\r\n        TokenPriceInUSD memory _price,\r\n        address _oracle\r\n    ) Ownable(msg.sender) {\r\n        if (_startingTime < block.timestamp) {\r\n            revert NeedGreaterThanCurrent();\r\n        }\r\n        priceFeed = AggregatorV3Interface(_oracle);\r\n        projectWallet = _pWallet;\r\n        roundHardCapInfo = _capInfo;\r\n        roundPeriod = 30 days;\r\n        minDaysBetweenClaims = 60 days;\r\n        claimPercentages = ClaimPercentages(\r\n            uint256(10),\r\n            uint256(8),\r\n            uint256(5)\r\n        );\r\n        token = IERC20(_token);\r\n        claimStartAt = block.timestamp + 5 minutes;\r\n        for (uint256 i = 0; i < _allowedStableCoins.length; i++) {\r\n            isAllowedStableCoin[_allowedStableCoins[i]] = true;\r\n        }\r\n        roundTimeInfo.r1StartTime = block.timestamp + 5 minutes;\r\n        roundTimeInfo.r1EndTime = (roundTimeInfo.r1StartTime + roundPeriod) - 1;\r\n        roundTimeInfo.r2StartTime = roundTimeInfo.r1EndTime + 1;\r\n        roundTimeInfo.r2EndTime =\r\n            (roundTimeInfo.r2StartTime + roundPeriod * 2) -\r\n            1;\r\n        roundTimeInfo.r3StartTime = roundTimeInfo.r2EndTime + roundPeriod + 1;\r\n        roundTimeInfo.r3EndTime = (roundTimeInfo.r3StartTime + roundPeriod) - 1;\r\n\r\n        roundTokenSaleInfo.r1TokenForSale = roundHardCapInfo.r1HardCap;\r\n        roundTokenSaleInfo.r2TokenForSale = roundHardCapInfo.r2HardCap;\r\n        roundTokenSaleInfo.r3TokenForSale = roundHardCapInfo.r3HardCap;\r\n        _setPrice(_price);\r\n    }\r\n\r\n    function updateOracle(address _new) public onlyOwner {\r\n        priceFeed = AggregatorV3Interface(_new);\r\n    }\r\n\r\n    function updateToken(address _new) public onlyOwner {\r\n        if (isClaimEnabled) {\r\n            revert AlreadyEnabled();\r\n        }\r\n        token = IERC20(_new);\r\n    }\r\n\r\n    function addAllowedStableCoin(\r\n        address[] memory _coins,\r\n        bool[] memory _status\r\n    ) public onlyOwner {\r\n        if (_coins.length != _status.length) {\r\n            revert LengthError();\r\n        }\r\n        for (uint256 i = 0; i < _coins.length; i++) {\r\n            isAllowedStableCoin[_coins[i]] = _status[i];\r\n        }\r\n    }\r\n\r\n    function enableClaim() public onlyOwner {\r\n        if (isClaimEnabled) {\r\n            revert AlreadyEnabled();\r\n        }\r\n        isClaimEnabled = true;\r\n        uint256 amount = roundHardCapInfo.r1HardCap +\r\n            roundHardCapInfo.r2HardCap +\r\n            roundHardCapInfo.r3HardCap;\r\n        token.transferFrom(msg.sender, address(this), amount);\r\n    }\r\n\r\n    function updateRound1Time(\r\n        uint256 _startTime\r\n    ) public onlyOwner returns (bool) {\r\n        if (_startTime < block.timestamp) {\r\n            revert NeedGreaterThanCurrent();\r\n        }\r\n        if (block.timestamp > roundTimeInfo.r1StartTime) {\r\n            revert RoundAlreadyStarted();\r\n        }\r\n        claimStartAt = _startTime;\r\n        roundTimeInfo.r1StartTime = _startTime;\r\n        roundTimeInfo.r1EndTime = (roundTimeInfo.r1StartTime + roundPeriod) - 1;\r\n        roundTimeInfo.r2StartTime = roundTimeInfo.r1EndTime + 1;\r\n        roundTimeInfo.r2EndTime =\r\n            (roundTimeInfo.r2StartTime + roundPeriod * 2) -\r\n            1;\r\n        roundTimeInfo.r3StartTime = roundTimeInfo.r2EndTime + 1;\r\n        roundTimeInfo.r3EndTime = (roundTimeInfo.r3StartTime + roundPeriod) - 1;\r\n        return true;\r\n    }\r\n\r\n    function updateRound2Time(\r\n        uint256 _startTime\r\n    ) public onlyOwner returns (bool) {\r\n        if (_startTime < block.timestamp) {\r\n            revert NeedGreaterThanCurrent();\r\n        }\r\n        if (block.timestamp > roundTimeInfo.r2StartTime) {\r\n            revert RoundAlreadyStarted();\r\n        }\r\n        roundTimeInfo.r1EndTime = block.timestamp;\r\n        roundTimeInfo.r2StartTime = _startTime;\r\n        roundTimeInfo.r2EndTime =\r\n            (roundTimeInfo.r2StartTime + roundPeriod * 2) -\r\n            1;\r\n        roundTimeInfo.r3StartTime = roundTimeInfo.r2EndTime + 1;\r\n        roundTimeInfo.r3EndTime = (roundTimeInfo.r3StartTime + roundPeriod) - 1;\r\n        return true;\r\n    }\r\n\r\n    function updateRound3Time(\r\n        uint256 _startTime\r\n    ) public onlyOwner returns (bool) {\r\n        if (_startTime < block.timestamp) {\r\n            revert NeedGreaterThanCurrent();\r\n        }\r\n        if (block.timestamp > roundTimeInfo.r3StartTime) {\r\n            revert RoundAlreadyStarted();\r\n        }\r\n        roundTimeInfo.r2EndTime = block.timestamp;\r\n        roundTimeInfo.r3StartTime = _startTime;\r\n        roundTimeInfo.r3EndTime = (roundTimeInfo.r3StartTime + roundPeriod) - 1;\r\n        return true;\r\n    }\r\n\r\n    function updateTokenPrice(\r\n        TokenPriceInUSD memory _price\r\n    ) public onlyOwner returns (bool) {\r\n        _setPrice(_price);\r\n        return true;\r\n    }\r\n\r\n    function _setPrice(TokenPriceInUSD memory _price) private {\r\n        if (block.timestamp > roundTimeInfo.r1StartTime) {\r\n            revert RoundAlreadyStarted();\r\n        }\r\n        tokenPriceInUSD = _price;\r\n    }\r\n\r\n    function retrieveStuckedAsset(\r\n        address _tokenAddr,\r\n        uint256 _amount,\r\n        address _toWallet,\r\n        bool _eth\r\n    ) public onlyOwner returns (bool) {\r\n        if (block.timestamp < roundTimeInfo.r3EndTime) {\r\n            revert Round3NotFinished();\r\n        }\r\n        IERC20(_tokenAddr).transfer(_toWallet, _amount);\r\n        if (address(this).balance > 0 && _eth) {\r\n            (bool success, ) = projectWallet.call{value: address(this).balance}(\r\n                \"\"\r\n            );\r\n            if (!success) revert TransferFailed();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    receive() external payable {\r\n        buy(PaymentType.ETH, msg.value, address(0));\r\n    }\r\n\r\n    function buy(\r\n        PaymentType _type,\r\n        uint256 _amountToPay,\r\n        address _paymentToken\r\n    ) public payable returns (bool) {\r\n        if (tokenPriceInUSD.presale1 == 0) {\r\n            revert NotStarted();\r\n        }\r\n        uint256 currentTime = block.timestamp;\r\n        address currentInvestor = msg.sender;\r\n        uint256 amountToPay;\r\n        UserInfo storage user = userInfo[currentInvestor];\r\n        if (_type == PaymentType.ETH) {\r\n            amountToPay = getConversionRate(msg.value);\r\n            (bool success, ) = projectWallet.call{value: msg.value}(\"\");\r\n            if (!success) revert TransferFailed();\r\n            user.totalETHInvested += amountToPay;\r\n            presaleInfo.raisedTotalETH += amountToPay;\r\n        } else if (_type == PaymentType.StableCoin) {\r\n            amountToPay = _amountToPay;\r\n            if (_paymentToken != address(0)) {\r\n                if (!isAllowedStableCoin[_paymentToken]) {\r\n                    revert SCNotAllowed();\r\n                }\r\n                IERC20(_paymentToken).transferFrom(\r\n                    msg.sender,\r\n                    projectWallet,\r\n                    amountToPay\r\n                );\r\n                user.totalSCInvested += amountToPay;\r\n            }\r\n            presaleInfo.raisedTotalSCToken += amountToPay;\r\n        }\r\n\r\n        uint256 amount;\r\n\r\n        if (\r\n            currentTime >= roundTimeInfo.r1StartTime &&\r\n            currentTime <= roundTimeInfo.r1EndTime\r\n        ) {\r\n            amount = (amountToPay * tokenPriceInUSD.presale1) / precision;\r\n            if (roundTokenSaleInfo.r1TokenForSale < amount) {\r\n                revert AmountNotAvailableForSale();\r\n            }\r\n            roundTokenSaleInfo.r1TokenForSale -= amount;\r\n            roundTokenSaleInfo.r1SoldToken += amount;\r\n            user.r1Purchased += amount;\r\n        } else if (\r\n            currentTime >= roundTimeInfo.r2StartTime &&\r\n            currentTime <= roundTimeInfo.r2EndTime\r\n        ) {\r\n            amount = (amountToPay * tokenPriceInUSD.presale2) / precision;\r\n            if (roundTokenSaleInfo.r2TokenForSale < amount) {\r\n                revert AmountNotAvailableForSale();\r\n            }\r\n            roundTokenSaleInfo.r2TokenForSale -= amount;\r\n            roundTokenSaleInfo.r2SoldToken += amount;\r\n            user.r2Purchased += amount;\r\n        } else if (\r\n            currentTime >= roundTimeInfo.r1StartTime &&\r\n            currentTime <= roundTimeInfo.r1EndTime\r\n        ) {\r\n            amount = (amountToPay * tokenPriceInUSD.presale3) / precision;\r\n            if (roundTokenSaleInfo.r3TokenForSale < amount) {\r\n                revert AmountNotAvailableForSale();\r\n            }\r\n\r\n            roundTokenSaleInfo.r3TokenForSale -= amount;\r\n            roundTokenSaleInfo.r3SoldToken += amount;\r\n            user.r3Purchased += amount;\r\n        } else {\r\n            revert RoundNotMatch();\r\n        }\r\n        if (amount <= 0) {\r\n            revert AmountZero();\r\n        }\r\n        presaleInfo.soldToken += amount;\r\n        user.totalPurchased += amount;\r\n        user.remainToClaim += amount;\r\n        emit TokenPurchased(amount, amountToPay, currentInvestor);\r\n        return true;\r\n    }\r\n\r\n    function claim() public returns (bool) {\r\n        if (block.timestamp < claimStartAt && !isClaimEnabled) {\r\n            revert ClaimNotEnabled();\r\n        }\r\n\r\n        UserInfo storage _user = userInfo[msg.sender];\r\n        if (\r\n            _user.lastClaimedAt != 0 &&\r\n            block.timestamp < _user.lastClaimedAt + minDaysBetweenClaims\r\n        ) {\r\n            revert DelayNotOver();\r\n        }\r\n        uint256 amount;\r\n        uint256 _timeGap;\r\n\r\n        if (block.timestamp > roundTimeInfo.r3EndTime + 400 days) {\r\n            amount = _user.remainToClaim;\r\n        } else {\r\n            _timeGap =\r\n                block.timestamp -\r\n                (_user.lastClaimedAt == 0 ? claimStartAt : _user.lastClaimedAt);\r\n            uint256 _daysDiff;\r\n            if (_user.lastClaimedAt == 0 && _daysDiff == 0) _daysDiff = 1;\r\n            else _daysDiff += (_timeGap / minDaysBetweenClaims);\r\n            if (block.timestamp > roundTimeInfo.r1StartTime) {\r\n                if (_user.r1Purchased > _user.r1Claimed) {\r\n                    uint256 toBeClaim1 = (_user.r1Purchased *\r\n                        claimPercentages.presale1) / 100;\r\n                    if (toBeClaim1 > _user.r1Purchased - _user.r1Claimed) {\r\n                        toBeClaim1 = _user.r1Purchased - _user.r1Claimed;\r\n                    }\r\n                    _user.r1Claimed += toBeClaim1;\r\n                    amount += toBeClaim1;\r\n                }\r\n            }\r\n            if (block.timestamp > roundTimeInfo.r2StartTime) {\r\n                if (_user.r2Purchased > _user.r2Claimed) {\r\n                    uint256 toBeClaim2 = (_user.r2Purchased *\r\n                        claimPercentages.presale2) / 100;\r\n                    if (toBeClaim2 > _user.r2Purchased - _user.r2Claimed) {\r\n                        toBeClaim2 = _user.r2Purchased - _user.r2Claimed;\r\n                    }\r\n                    _user.r2Claimed += toBeClaim2;\r\n                    amount += toBeClaim2;\r\n                }\r\n            }\r\n            if (block.timestamp > roundTimeInfo.r3StartTime) {\r\n                if (_user.r3Purchased > _user.r3Claimed) {\r\n                    uint256 toBeClaim3 = (_user.r3Purchased *\r\n                        claimPercentages.presale3) / 100;\r\n                    if (toBeClaim3 > _user.r3Purchased - _user.r3Claimed) {\r\n                        toBeClaim3 = _user.r3Purchased - _user.r3Claimed;\r\n                    }\r\n                    _user.r3Claimed += toBeClaim3;\r\n                    amount += toBeClaim3;\r\n                }\r\n            }\r\n        }\r\n        if (_user.remainToClaim < amount) {\r\n            amount = _user.remainToClaim;\r\n        }\r\n        if (amount == 0) {\r\n            revert NoAmountToClaim();\r\n        }\r\n        _user.totalClaimed += amount;\r\n        _user.remainToClaim -= amount;\r\n        _user.lastClaimedAt = block.timestamp;\r\n        token.transfer(msg.sender, amount);\r\n        emit TokenClaimed(amount, block.timestamp, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    function getConversionRate(\r\n        uint256 ethAmount\r\n    ) internal view returns (uint256) {\r\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\r\n        uint256 ethPrice = uint256(answer) * 10000000000;\r\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1000000000000000000;\r\n        return ethAmountInUsd;\r\n    }\r\n\r\n    function round()\r\n        public\r\n        view\r\n        returns (\r\n            string memory _round,\r\n            uint256 endTime,\r\n            uint256 _hardcap,\r\n            uint256 _soldToken,\r\n            uint _price\r\n        )\r\n    {\r\n        uint currentTime = block.timestamp;\r\n        if (\r\n            currentTime >= roundTimeInfo.r1StartTime &&\r\n            currentTime <= roundTimeInfo.r1EndTime\r\n        ) {\r\n            string memory Round = \"Private Sale 1\";\r\n            return (\r\n                Round,\r\n                roundTimeInfo.r1EndTime,\r\n                roundHardCapInfo.r1HardCap,\r\n                roundTokenSaleInfo.r1SoldToken,\r\n                tokenPriceInUSD.presale1\r\n            );\r\n        } else if (\r\n            currentTime >= roundTimeInfo.r2StartTime &&\r\n            currentTime <= roundTimeInfo.r2EndTime\r\n        ) {\r\n            string memory Round = \"Private Sale 2\";\r\n            return (\r\n                Round,\r\n                roundTimeInfo.r2EndTime,\r\n                roundHardCapInfo.r2HardCap,\r\n                roundTokenSaleInfo.r2SoldToken,\r\n                tokenPriceInUSD.presale2\r\n            );\r\n        } else if (\r\n            currentTime >= roundTimeInfo.r3StartTime &&\r\n            currentTime <= roundTimeInfo.r3EndTime\r\n        ) {\r\n            string memory Round = \"Public Sale 1\";\r\n            return (\r\n                Round,\r\n                roundTimeInfo.r3EndTime,\r\n                roundHardCapInfo.r3HardCap,\r\n                roundTokenSaleInfo.r3SoldToken,\r\n                tokenPriceInUSD.presale3\r\n            );\r\n        } else {\r\n            require(false, \"Please check ICO time\");\r\n        }\r\n    }\r\n\r\n    function isOverRound1() public view returns (bool) {\r\n        if (\r\n            block.timestamp > roundTimeInfo.r1EndTime ||\r\n            roundTokenSaleInfo.r1TokenForSale == 0\r\n        ) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isOverRound2() public view returns (bool) {\r\n        if (\r\n            block.timestamp > roundTimeInfo.r2EndTime ||\r\n            roundTokenSaleInfo.r2TokenForSale == 0\r\n        ) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isOverRound3() public view returns (bool) {\r\n        if (\r\n            block.timestamp > roundTimeInfo.r3EndTime ||\r\n            roundTokenSaleInfo.r3TokenForSale == 0\r\n        ) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function getPresaleInfo() public view returns (PresaleInfo memory) {\r\n        return presaleInfo;\r\n    }\r\n    function getRoundTimeInfo() public view returns (RoundTimeInfo memory) {\r\n        return roundTimeInfo;\r\n    }\r\n    function getRoundHardCapInfo()\r\n        public\r\n        view\r\n        returns (RoundHardCapInfo memory)\r\n    {\r\n        return roundHardCapInfo;\r\n    }\r\n    function getRoundTokenSaleInfo()\r\n        public\r\n        view\r\n        returns (RoundTokenSaleInfo memory)\r\n    {\r\n        return roundTokenSaleInfo;\r\n    }\r\n    function getUserInfo(address _user) public view returns (UserInfo memory) {\r\n        return userInfo[_user];\r\n    }\r\n    function getTokenPriceInUSD() public view returns (TokenPriceInUSD memory) {\r\n        return tokenPriceInUSD;\r\n    }\r\n    function getClaimPercentages()\r\n        public\r\n        view\r\n        returns (ClaimPercentages memory)\r\n    {\r\n        return claimPercentages;\r\n    }\r\n    function getClaimStartAt() public view returns (uint256) {\r\n        return claimStartAt;\r\n    }\r\n    function getMinDaysBetweenClaims() public view returns (uint256) {\r\n        return minDaysBetweenClaims;\r\n    }\r\n    function getIsAllowedStableCoin(address _token) public view returns (bool) {\r\n        return isAllowedStableCoin[_token];\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}