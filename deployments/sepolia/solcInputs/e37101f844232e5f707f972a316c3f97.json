{
  "language": "Solidity",
  "sources": {
    "contracts/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.20;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract StakeGuard is Ownable {\r\n    error AmountZero();\r\n    error TotalAllocationReached();\r\n    error NotStaker();\r\n    error AlreadyUnstaked();\r\n    error DurationNotOver();\r\n\r\n    IERC20 private token;\r\n    uint256 private stakeId;\r\n    uint256 private totalAllocationForReward = 11000000 * 10 ** 18;\r\n    uint256 private rewardAccumulated;\r\n    enum PackageType {\r\n        OneMonth,\r\n        ThreeMonths,\r\n        SixMonths,\r\n        TwelveMonths\r\n    }\r\n\r\n    struct PackageDuration {\r\n        uint256 oneMonth;\r\n        uint256 threeMonth;\r\n        uint256 sixMonth;\r\n        uint256 twelveMonth;\r\n    }\r\n    struct APYPackage {\r\n        uint256 oneMonth;\r\n        uint256 threeMonth;\r\n        uint256 sixMonth;\r\n        uint256 twelveMonth;\r\n    }\r\n\r\n    struct StakeInfo {\r\n        uint256 stakeId;\r\n        address staker;\r\n        uint256 stakedAt;\r\n        uint256 unstakeAt;\r\n        uint256 stakedAmount;\r\n        bool isUnstaked;\r\n        PackageType package;\r\n        uint256 reward;\r\n    }\r\n\r\n    mapping(uint256 => StakeInfo) private stakeIdToStakeInfo;\r\n    mapping(address => uint256[]) private userStakeIds;\r\n\r\n    APYPackage private apy;\r\n    PackageDuration private packageDuration;\r\n    PackageType private packageType;\r\n\r\n    event Staked(address indexed user, uint256 amount, PackageType packageType);\r\n    event Unstaked(address indexed user, uint256 amount);\r\n\r\n    constructor() Ownable(msg.sender) {\r\n        apy = APYPackage(3, 5, 8, 11);\r\n        packageDuration = PackageDuration(\r\n            30 days,\r\n            3 * 30 days,\r\n            6 * 30 days,\r\n            12 * 30 days\r\n        );\r\n    }\r\n\r\n    function getToken() public view returns (IERC20) {\r\n        return token;\r\n    }\r\n\r\n    function getStakeId() public view returns (uint256) {\r\n        return stakeId;\r\n    }\r\n    function getRewardAccumulated() public view returns (uint256) {\r\n        return rewardAccumulated;\r\n    }\r\n\r\n    function getTotalAllocationForReward() public view returns (uint256) {\r\n        return totalAllocationForReward;\r\n    }\r\n\r\n    function getAPYPackage() public view returns (APYPackage memory) {\r\n        return apy;\r\n    }\r\n\r\n    function getPackageDuration() public view returns (PackageDuration memory) {\r\n        return packageDuration;\r\n    }\r\n\r\n    function getPackageType() public view returns (PackageType) {\r\n        return packageType;\r\n    }\r\n\r\n    function getUserStakeIds(\r\n        address _user\r\n    ) public view returns (uint256[] memory) {\r\n        return userStakeIds[_user];\r\n    }\r\n\r\n    function getStakeIdToStakeInfo(\r\n        uint256 _stakeId\r\n    ) public view returns (StakeInfo memory) {\r\n        return stakeIdToStakeInfo[_stakeId];\r\n    }\r\n\r\n    function fetchUserStakeInfos(\r\n        address _user\r\n    ) public view returns (StakeInfo[] memory) {\r\n        uint256[] memory listOfIds = userStakeIds[_user];\r\n        StakeInfo[] memory items = new StakeInfo[](listOfIds.length);\r\n        for (uint256 i = 0; i < listOfIds.length; i++) {\r\n            uint256 __id = listOfIds[i];\r\n            items[__id] = stakeIdToStakeInfo[__id];\r\n        }\r\n        return items;\r\n    }\r\n\r\n    function enableStaking(address _token) public onlyOwner {\r\n        token = IERC20(_token);\r\n        token.transferFrom(msg.sender, address(this), totalAllocationForReward);\r\n    }\r\n\r\n    function setTotalAllocationForReward(\r\n        uint256 _totalAllocationForReward\r\n    ) public onlyOwner {\r\n        totalAllocationForReward = _totalAllocationForReward;\r\n    }\r\n\r\n    function setAPYPackage(APYPackage memory _apy) public onlyOwner {\r\n        apy = _apy;\r\n    }\r\n\r\n    function setPackageDuration(\r\n        PackageDuration memory _packageDuration\r\n    ) public onlyOwner {\r\n        packageDuration = _packageDuration;\r\n    }\r\n\r\n    function stake(uint256 amount, PackageType _packageType) external {\r\n        if (amount == 0) {\r\n            revert AmountZero();\r\n        }\r\n        stakeId++;\r\n        token.transferFrom(msg.sender, address(this), amount);\r\n        uint256 ut = _packageType == PackageType.OneMonth\r\n            ? packageDuration.oneMonth\r\n            : _packageType == PackageType.ThreeMonths\r\n                ? packageDuration.threeMonth\r\n                : _packageType == PackageType.SixMonths\r\n                    ? packageDuration.sixMonth\r\n                    : packageDuration.twelveMonth;\r\n        uint256 __apy = _packageType == PackageType.OneMonth\r\n            ? apy.oneMonth\r\n            : _packageType == PackageType.ThreeMonths\r\n                ? apy.threeMonth\r\n                : _packageType == PackageType.SixMonths\r\n                    ? apy.sixMonth\r\n                    : apy.twelveMonth;\r\n        uint256 _precision = _packageType == PackageType.OneMonth\r\n            ? 1\r\n            : _packageType == PackageType.ThreeMonths\r\n                ? 3\r\n                : _packageType == PackageType.SixMonths\r\n                    ? 6\r\n                    : 12;\r\n        uint256 _reward = ((amount * __apy) / 100) / (12 / _precision);\r\n        rewardAccumulated += _reward;\r\n        if (rewardAccumulated > totalAllocationForReward) {\r\n            revert TotalAllocationReached();\r\n        }\r\n        userStakeIds[msg.sender].push(stakeId);\r\n        stakeIdToStakeInfo[stakeId] = StakeInfo(\r\n            stakeId,\r\n            msg.sender,\r\n            block.timestamp,\r\n            block.timestamp + ut,\r\n            amount,\r\n            false,\r\n            _packageType,\r\n            _reward\r\n        );\r\n\r\n        emit Staked(msg.sender, amount, packageType);\r\n    }\r\n\r\n    function unstake(uint256 _stakeId) public {\r\n        StakeInfo storage info = stakeIdToStakeInfo[_stakeId];\r\n        if (info.staker != msg.sender) {\r\n            revert NotStaker();\r\n        }\r\n        if (info.isUnstaked) {\r\n            revert AlreadyUnstaked();\r\n        }\r\n        if (block.timestamp < info.unstakeAt) {\r\n            revert DurationNotOver();\r\n        }\r\n        info.isUnstaked = true;\r\n        token.transfer(info.staker, info.stakedAmount + info.reward);\r\n        emit Unstaked(msg.sender, info.stakedAmount + info.reward);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}